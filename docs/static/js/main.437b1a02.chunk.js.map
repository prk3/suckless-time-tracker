{"version":3,"sources":["sync.tsx","reportWebVitals.ts","utils.ts","task.tsx","tasks.tsx","week-summary.tsx","week-timeline.tsx","week.tsx","App.tsx","index.tsx","state.tsx"],"names":["retrieveSync","syncString","sync","window","localStorage","getItem","JSON","parse","persistSync","setItem","stringify","serializeSync","syncContext","React","createContext","status","SyncProvider","props","children","useState","SyncProviderInner","initSync","Provider","value","state","updateState","latestStateRef","useRef","syncRef","handleStateUpdateRef","setStatus","lastResyncRef","Date","mountedRef","syncWithServerRef","current","fetch","storageUrl","method","headers","authToken","catch","_error","Error","then","response","text","newlineIndex","indexOf","Number","substring","deserializeState","versionAndState","serverVersion","serverState","saving","version","dirty","createStateUpdateHandler","flush","error","console","debounce","cancel","body","serializeState","sendStateToServer","becameDirty","trailing","leading","useEffect","resync","addEventListener","removeEventListener","interval","setInterval","now","getTime","clearInterval","useSync","useContext","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","groupTasksByTaskId","tasks","Object","fromEntries","map","task","id","cs","output","classes","forEach","c","assert","condition","trace","Task","fn","active","timeSpent","onActiveChange","onEstimationChange","onNameChange","onDelete","innerRef","timeSpentElement","estimation","estimationClassName","estimationSpent","as","estimationRatio","className","Math","min","title","toFixed","max","onClick","ev","target","currentTarget","ref","name","onChange","type","step","confirm","Tasks","filter","setFilter","taskMap","useMemo","story","events","event","taskId","push","groupEventsByTaskId","updateTaskEstimation","undefined","deleted","updateTaskActive","activeTask","newEvents","length","end_time","DateTime","local","start_time","deleteTask","filteredTasks","trim","includes","index","totalTime","Duration","fromObject","seconds","plus","diff","calculateTotalTimeFromEvents","draggableId","String","provided","style","padding","draggableProps","dragHandleProps","floor","random","setTimeout","document","querySelector","focus","placeholder","alert","onDragEnd","result","source","destination","reason","sourceIndex","findIndex","e","destinationIndex","splice","reorderedItem","droppableId","droppableProps","formatDuration","duration","minutes","WeekSummary","startOfWeek","weekEvents","endOfWeek","endOf","selectWeekEvents","weekLog","week","day","weekday","taskDuration","weekLogFromEvents","days","toFormat","entries","keys","values","reduce","acc","next","toString","WeekTimeline","weekFromEvents","range","hour","time","top","startOf","height","start","end","end_","equals","heightFromStartAndEnd","lines","linesCountFromHeight","WebkitLineClamp","Week","setStartOfWeek","mode","setMode","minus","weeks","App","useReducer","forceUpdate","global","dbg","a","log","ReactDOM","render","StrictMode","getElementById","initialState","settings","manDayDuration","hours","eventRetentionMonths","stateContext","stateString","obj","fromISO","retrieveState","persistState","StateProvider","setState","stateRef","dirtyRef","debouncedPersistRef","beforeunload","blur","updateFunction","newState"],"mappings":"yPAuGA,SAASA,IACL,IAlE4BC,EAkExBC,EAAOC,OAAOC,aAAaC,QAAQ,QACvC,OAAIH,GAnEwBD,EAoEDC,EAnEjBI,KAAKC,MAAMN,KAqErBO,EA5EqC,WA8ExC,CAED,SAASA,EAAYN,GACjBC,OAAOC,aAAaK,QAAQ,OA/EzB,SAAuBP,GAC1B,OAAOI,KAAKI,UAAUR,EACzB,CA6EuCS,CAAcT,GACrD,CAED,IAAMU,EAAcC,IAAMC,cAAc,CAAEC,OAAQ,QAE3C,SAASC,EAAaC,GAA2B,IAC9CC,EAAaD,EAAbC,SAD6C,EAEtCL,IAAMM,SAASnB,GAAvBE,EAF8C,oBAInD,OACc,OAATA,EACM,cAACkB,EAAD,CAAmBC,SAAUnB,EAA7B,SAAoCgB,IACpC,cAACN,EAAYU,SAAb,CAAsBC,MAAO,CAAER,OAAQ,OAAvC,SAAiDG,GAE/D,CAEM,SAASE,EAAkBH,GAA2C,IACjEI,EAAuBJ,EAAvBI,SAAUH,EAAaD,EAAbC,SADsD,EAGzCC,cAAvBK,EAHgE,EAGhEA,MAAOC,EAHyD,EAGzDA,YACTC,EAAiBb,IAAMc,OAAOH,GAE9BI,EAAUf,IAAMc,OAAON,GAIvBQ,EAAuBhB,IAAMc,OAAyC,MAVJ,EAa5Cd,IAAMM,SAAiB,OAbqB,mBAajEJ,EAbiE,KAazDe,EAbyD,KAgBlEC,EAAgBlB,IAAMc,OAAO,IAAIK,MAGjCC,EAAapB,IAAMc,QAAO,GAG1BO,EAAoBrB,IAAMc,QAAO,WAjF3C,IAA4BzB,EAkFf+B,EAAWE,UAEhBL,EAAU,YApFU5B,EAqFD0B,EAAQO,QApFxBC,MAAM,GAAD,OAAIlC,EAAKmC,WAAT,WAA8B,CACtCC,OAAQ,MACRC,QAAS,CACL,cAAgB,UAAhB,OAA2BrC,EAAKsC,cAGnCC,OAAM,SAAAC,GACH,MAAM,IAAIC,MAAJ,kCACT,IACAC,MAAK,SAAAC,GACF,GAAwB,MAApBA,EAAS9B,OACT,OAAO8B,EACFC,OACAF,MAAK,SAAAE,GACF,IAAIC,EAAeD,EAAKE,QAAQ,MAGhC,MAAO,CAFOC,OAAOH,EAAKI,UAAU,EAAGH,IAC3BI,YAAiBL,EAAKI,UAAUH,EAAe,IAE9D,IAEJ,GAAwB,MAApBF,EAAS9B,OACd,MAAM,IAAI4B,MAAM,kCAEf,GAAwB,MAApBE,EAAS9B,OACd,OAAO,KAGP,MAAM,IAAI4B,MAAJ,qCAAwCE,EAAS9B,QAE9D,KAwDI6B,MAAK,SAAAQ,GACF,GAAKnB,EAAWE,SAEZiB,EAAiB,CAAC,IAAD,cACoBA,EADpB,GACVC,EADU,KACKC,EADL,KAgBjB,GAZI1B,EAAQO,QAAQoB,SAChB3B,EAAQO,QAAQoB,QAAS,EACzB3B,EAAQO,QAAQqB,SAAW,EAGvB5B,EAAQO,QAAQqB,QAAUH,IAC1BzB,EAAQO,QAAQsB,OAAQ,EACxB7B,EAAQO,QAAQqB,SAAW,IAK/B5B,EAAQO,QAAQqB,QAAUH,EAC1B,MAAM,IAAIV,MAAM,8DAIf,GAAIf,EAAQO,QAAQqB,UAAYH,OAIhC,MAAIzB,EAAQO,QAAQqB,QAAUH,IAAkBzB,EAAQO,QAAQsB,MAQjE,MAAM,IAAId,MAAM,iDAPhBf,EAAQO,QAAQqB,QAAUH,EAE1B3B,EAAeS,QAAUmB,EACzB7B,GAAY,kBAAM6B,CAAN,GAKf,CACJ,CACJ,IACAV,MAAK,WAM0B,IAAD,IALtBX,EAAWE,UAEhB3B,EAAYoB,EAAQO,SAEpBN,EAAqBM,QAAUuB,IAC3B9B,EAAQO,QAAQsB,OAEhB,UAAA5B,EAAqBM,eAArB,cAAAN,GACA,UAAAA,EAAqBM,eAArB,SAA8BwB,SAE9B7B,EAAU,UAEjB,IACAW,OAAM,SAAAmB,GACE3B,EAAWE,UAEhBL,EAAU,SACV+B,QAAQD,MAAM,6BACdC,QAAQD,MAAMA,GACjB,IACR,IAGD,SAASF,IACL,OAAOI,oBACH,WAAO,IAAD,EACF,GAAK7B,EAAWE,QAWhB,OARA,UAAAN,EAAqBM,eAArB,SAA8B4B,SAC9BlC,EAAqBM,QAAU,KAE/BP,EAAQO,QAAQoB,QAAS,EACzB3B,EAAQO,QAAQsB,OAAQ,EACxBjD,EAAYoB,EAAQO,SACpBL,EAAU,WA7L1B,SAA2BN,EAActB,GACrC,OAAOkC,MAAM,GAAD,OAAIlC,EAAKmC,WAAT,mBAA8BnC,EAAKsD,QAAU,GAAK,CAC1DlB,OAAQ,MACR0B,KAAMC,YAAezC,GACrBe,QAAS,CACL,cAAgB,UAAhB,OAA2BrC,EAAKsC,cAGnCC,OAAM,SAAAC,GACH,MAAM,IAAIC,MAAJ,oCACT,IACAC,MAAK,SAAAC,GACF,GAAwB,MAApBA,EAAS9B,OACT,OAAOb,EAAKsD,QAAU,EAErB,MAAwB,MAApBX,EAAS9B,OACR,IAAI4B,MAAM,kCAES,MAApBE,EAAS9B,OACR,IAAI4B,MAAM,4DAGV,IAAIA,MAAJ,qCAAwCE,EAAS9B,QAE9D,GACR,CAsKsBmD,CAAkBxC,EAAeS,QAASP,EAAQO,SACpDS,MAAK,SAAAY,GAQ0B,IAAD,EAPtBvB,EAAWE,UAEhBP,EAAQO,QAAQoB,QAAS,EACzB3B,EAAQO,QAAQqB,QAAUA,EAC1BhD,EAAYoB,EAAQO,SAEpBN,EAAqBM,QAAUuB,IAC3B9B,EAAQO,QAAQsB,OAChB,UAAA5B,EAAqBM,eAArB,cAAAN,GACAC,EAAU,UAEVA,EAAU,UAEjB,IACAW,OAAM,SAAAmB,GACH,GAAK3B,EAAWE,QAAhB,CAEA,IAUiB,EAVbgC,EAAcvC,EAAQO,QAAQsB,MAUlC,GARA7B,EAAQO,QAAQoB,QAAS,EACzB3B,EAAQO,QAAQsB,OAAQ,EACxBjD,EAAYoB,EAAQO,SAEpB0B,QAAQD,MAAM,mCACdC,QAAQD,MAAMA,GAEd/B,EAAqBM,QAAUuB,IAC3BS,EACA,UAAAtC,EAAqBM,eAArB,cAAAN,GACAC,EAAU,cAEVA,EAAU,QAhBiB,CAkBlC,GACR,GAnQmB,IAqQpB,CAAEsC,UAAU,EAAMC,SAAS,GAElC,CAoED,OAjEAxD,IAAMyD,WAAU,WAE2B,IAAD,EAAlC9C,IAAUE,EAAeS,UACzBT,EAAeS,QAAUX,EAEpBI,EAAQO,QAAQsB,QACjB7B,EAAQO,QAAQsB,OAAQ,EACxBjD,EAAYoB,EAAQO,SAGiB,OAAjCN,EAAqBM,SACrBL,EAAU,UAIlB,UAAAD,EAAqBM,eAArB,cAAAN,GAEP,GAAE,CAACL,IAGJX,IAAMyD,WAAU,WACZ,IAAMC,EAAS,WAE0B,OAAjC1C,EAAqBM,UACrBN,EAAqBM,QAAQ4B,SAC7BlC,EAAqBM,QAAU,KAE/BD,EAAkBC,UAElBJ,EAAcI,QAAU,IAAIH,KAEnC,EAED,OADA7B,OAAOqE,iBAAiB,QAASD,GAC1B,kBAAMpE,OAAOsE,oBAAoB,QAASF,EAA1C,CACV,GAAE,IAGH1D,IAAMyD,WAAU,WACZ,IAaMI,EAAWvE,OAAOwE,aAbT,WACX,IAAIC,EAAM,IAAI5C,KAEuB,OAAjCH,EAAqBM,SAAoByC,EAAIC,UAAY9C,EAAcI,QAAQ0C,UAzTpE,OA0TXhD,EAAqBM,QAAQ4B,SAC7BlC,EAAqBM,QAAU,KAE/BD,EAAkBC,UAElBJ,EAAcI,QAAUyC,EAE/B,GA9TwB,KAiUzB,OAAO,kBAAMzE,OAAO2E,cAAcJ,EAA3B,CACV,GAAE,IAGH7D,IAAMyD,WAAU,WAEZ,OADApC,EAAkBC,UACX,WAAO,IAAD,EACTF,EAAWE,SAAU,EACrB,UAAAN,EAAqBM,eAArB,SAA8B4B,SAC9BlC,EAAqBM,QAAU,IAClC,CACJ,GAAE,IAGC,cAACvB,EAAYU,SAAb,CAAsBC,MAAO,CAAER,UAA/B,SACKG,GAGZ,CAEM,SAAS6D,IACZ,OAAOlE,IAAMmE,WAAWpE,EAC3B,C,kCCjVcqE,IAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,6BAAqBvC,MAAK,YAAkD,IAA/CwC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOF,GACPG,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAQN,EACT,GAEJ,C,2ICRM,SAASO,EAAmBC,GAC/B,OAAOC,OAAOC,YAAYF,EAAMG,KAAI,SAAAC,GAAI,MAAI,CAACA,EAAKC,GAAID,EAAd,IAC3C,CA0BM,SAASE,IAA2C,IACvD,IAAIC,EAAS,GAD0C,mBAArCC,EAAqC,yBAArCA,EAAqC,gBAOvD,OALAA,EAAQC,SAAQ,SAAAC,IACF,IAANA,IACAH,EAASA,EAAS,IAAMG,EAE/B,IACMH,CACV,CAEM,SAASI,EAAOC,GACnB,IAAKA,EAGD,MAFAzC,QAAQD,MAAM,qBACdC,QAAQ0C,QACF,IAAI5D,MAAM,mBAEvB,C,MAEM,I,OChCA,SAAS6D,EAAT,GAA6H,IDgC/FC,EChCdX,EAA4G,EAA5GA,KAAMY,EAAsG,EAAtGA,OAAQC,EAA8F,EAA9FA,UAAWC,EAAmF,EAAnFA,eAAgBC,EAAmE,EAAnEA,mBAAoBC,EAA+C,EAA/CA,aAAcC,EAAiC,EAAjCA,SAAUC,EAAuB,EAAvBA,SAsBpGC,EAAmB,KAEvB,GAAwB,OAApBnB,EAAKoB,WAAqB,CAC1B,IAEIC,EAFAC,EAAkBT,EAAUU,GAAG,SAtCd,EAuCjBC,EAAkBF,EAAkBtB,EAAKoB,WAGbC,EAAvBG,EAAkB,GAA2B,KAC7CA,EAAkB,GAA2B,QAC7CA,EAAkB,GAA2B,MACA,WAEtDL,EACI,yCAEK,IACD,0BACIM,UAAWvB,EAAGmB,GACd5F,MAAOiG,KAAKC,IAAIH,EAAiB,GACjCI,MAAK,UAAKN,EAAgBO,QAAQ,GAA7B,eAAsC7B,EAAKoB,WAA3C,aACLU,IAAI,QAInB,CAED,OACI,sBACIL,UAAWvB,EAAG,OAAQU,GAAU,UAEhCmB,SDpByBpB,EC1BZ,WACjBG,GAAgBF,EACnB,EDwBiE,SAACoB,GAC/DA,EAAGC,SAAWD,EAAGE,eACjBvB,EAAGqB,EAEV,GCiBWG,IAAKjB,EAJT,UAMI,8BAAK,0BAAUO,UAAU,OAAOhG,MAAOuE,EAAKoC,KAAMC,SArDvC,SAACL,GAChBhB,EAAagB,EAAGC,OAAOxG,MAC1B,MAoDO,gCAAM,eACF,wBAAQ6G,KAAK,SAASb,UAAU,eAAeM,QAvC/B,WACxBhB,GAAqBf,EAAKoB,YAAc,GAAK,GAAM,KACtD,EAqCW,eACC,IACD,uBACIK,UAAU,aACVE,IAAI,IACJY,KAAK,IACLD,KAAK,SACL7G,MAAOuE,EAAKoB,YAAc,GAC1BiB,SAvDS,SAACL,GACtBjB,EAAmB5D,OAAO6E,EAAGC,OAAOxG,QAAU,KACjD,IAuDY,IACD,wBAAQ6G,KAAK,SAASb,UAAU,cAAcM,QAtD9B,WACxBhB,GAAoBf,EAAKoB,YAAc,GAAK,EAC/C,EAoDW,eACC,IACAD,EACA,IACD,wBAAQmB,KAAK,SAASb,UAAU,SAASM,QAAS,kBAAM1H,OAAOmI,QAAQ,cAAgBvB,GAArC,EAAlD,yBArBCjB,EAAKC,GAyBrB,C,kBC3EM,SAASwC,IAAS,IAAD,EACWpH,cAAvBK,EADY,EACZA,MAAOC,EADK,EACLA,YACPV,EAAWgE,cAAXhE,OAFY,EAGQF,IAAMM,SAAS,IAHvB,mBAGbqH,EAHa,KAGLC,EAHK,KAKhBC,EAAU7H,IAAM8H,SAAQ,kBAAMlD,EAAmBjE,EAAMkE,MAA/B,GAAuC,CAAClE,EAAMkE,QACtEkD,EAAQ/H,IAAM8H,SAAQ,kBFjBvB,SAA6BE,GAChC,IADgF,EAC5ED,EAAuC,CAAC,EADoC,cAG9DC,GAH8D,IAGhF,2BAA0B,CAAC,IAAlBC,EAAiB,QAClBF,EAAME,EAAMC,QACZH,EAAME,EAAMC,QAAQC,KAAKF,GAEzBF,EAAME,EAAMC,QAAU,CAACD,EAE9B,CAT+E,+BAWhF,OAAOF,CACV,CEKmCK,CAAoBzH,EAAMqH,OAAhC,GAAyC,CAACrH,EAAMqH,SA4CpEK,EAAuB,SAACnD,GAAD,OAAgB,SAACmB,GAE1Cb,OAAuB8C,IAAhBT,EAAQ3C,IACfM,GAA+B,IAAxBqC,EAAQ3C,GAAIqD,SAEnB3H,GAAY,SAAAD,GAAK,kCACVA,GADU,IAEbkE,MAAOlE,EAAMkE,MAAMG,KAAI,SAAAC,GAAI,OAAIA,EAAKC,KAAOA,EACrCD,EADyB,2BAEpBA,GAFoB,IAEdoB,cAFU,KAFd,GAOpB,CAZ4B,EAcvBmC,EAAmB,SAACtD,GAAD,OAAgB,SAACW,GAEtCL,OAAuB8C,IAAhBT,EAAQ3C,IACfM,GAA+B,IAAxBqC,EAAQ3C,GAAIqD,SAEnB3H,GAAY,SAAAD,GACR,GAAIkF,EAAQ,CAERL,EAAO7E,EAAM8H,aAAevD,GAE5B,IAAIwD,EAAS,YAAO/H,EAAMqH,QAgB1B,OAdyB,OAArBrH,EAAM8H,aACNjD,EAAOkD,EAAUC,OAAS,GAC1BnD,EAAoD,OAA7CkD,EAAUA,EAAUC,OAAS,GAAGC,UACvCF,EAAUA,EAAUC,OAAS,GAA7B,2BACOD,EAAUA,EAAUC,OAAS,IADpC,IAEIC,SAAUC,WAASC,WAG3BJ,EAAUP,KAAK,CACXD,OAAQhD,EACR6D,WAAYF,WAASC,QACrBF,SAAU,OAGP,2BACAjI,GADP,IAEI8H,WAAYvD,EACZ8C,OAAQU,GAEf,CAEGlD,EAAO7E,EAAM8H,aAAevD,GAE5B,IAAIwD,EAAS,YAAO/H,EAAMqH,QAU1B,OARAxC,EAAOkD,EAAUC,OAAS,GAC1BnD,EAAoD,OAA7CkD,EAAUA,EAAUC,OAAS,GAAGC,UAEvCF,EAAUA,EAAUC,OAAS,GAA7B,2BACOD,EAAUA,EAAUC,OAAS,IADpC,IAEIC,SAAUC,WAASC,UAGhB,2BACAnI,GADP,IAEI8H,WAAY,KACZT,OAAQU,GAGnB,GACJ,CApDwB,EAsDnBM,EAAa,SAAC9D,GAAD,OAAgB,WAE/BM,OAAuB8C,IAAhBT,EAAQ3C,IACfM,GAA+B,IAAxBqC,EAAQ3C,GAAIqD,SAEnB3H,GAAY,SAAAD,GACR,IAAIqH,EACAS,EAeJ,OAdI9H,EAAM8H,aAAevD,GAErBM,GADAwC,EAAM,YAAOrH,EAAMqH,SACLW,OAAS,GACvBnD,EAA8C,OAAvCwC,EAAOA,EAAOW,OAAS,GAAGC,UACjCZ,EAAOA,EAAOW,OAAS,GAAvB,2BACOX,EAAOA,EAAOW,OAAS,IAD9B,IAEIC,SAAUC,WAASC,UAEvBL,EAAa,OAEbT,EAASrH,EAAMqH,OACfS,EAAa9H,EAAM8H,YAGhB,2BACA9H,GADP,IAEIkE,MAAOlE,EAAMkE,MAAMG,KAAI,SAAAC,GAAI,OAAIA,EAAKC,KAAOA,EACrCD,EADyB,2BAEpBA,GAFoB,IAEdsD,SAAS,GAFC,IAI3BE,aACAT,UAEP,GACJ,CAhCkB,EAkCbiB,EAAgBtI,EAAMkE,MACvB8C,QAAO,SAAA1C,GAAI,OAAKA,EAAKsD,OAAV,IACXZ,QAAO,SAAA1C,GAAI,MAAsB,KAAlB0C,EAAOuB,QAAiBjE,EAAKoC,KAAK8B,SAASxB,EAAOuB,OAAtD,IAoBVrE,EAAQoE,EACTjE,KAAI,SAACC,EAAMmE,GACR,IAAIvD,EAASZ,EAAKC,KAAOvE,EAAM8H,WAC3B3C,EF9KT,SAAsCkC,GACzC,IAAIqB,EAAYC,WAASC,WAAW,CAAEC,QAAS,IAM/C,OAJAxB,EAAO1C,SAAQ,SAAA2C,GACXoB,EAAYA,EAAUI,MAAMxB,EAAMW,UAAYC,WAASC,SAASY,KAAKzB,EAAMc,YAC9E,IAEMM,CACV,CEsK2BM,CAA6B5B,EAAM9C,EAAKC,KAAO,IAE/D,OACI,cAAC,IAAD,CAAyB0E,YAAaC,OAAO5E,EAAKC,IAAKkE,MAAOA,EAA9D,SACK,SAACU,GAAD,OACG,qBAAKC,MAAO,CAAEC,QAAS,aAAvB,SACI,2DAASF,EAASG,gBAAoBH,EAASI,iBAA/C,IAAgE9C,IAAK0C,EAAS3D,SAA9E,SACI,cAACR,EAAD,CACIV,KAAMA,EACNY,OAAQA,EACRC,UAAWA,EACXG,cAxJRf,EAwJqCD,EAAKC,GAxJ3B,SAACmC,GAEpC7B,OAAuB8C,IAAhBT,EAAQ3C,IACfM,GAA+B,IAAxBqC,EAAQ3C,GAAIqD,SAEnB3H,GAAY,SAAAD,GAAK,kCACVA,GADU,IAEbkE,MAAOlE,EAAMkE,MAAMG,KAAI,SAAAC,GAAI,OAAIA,EAAKC,KAAOA,EACrCD,EADyB,2BAEpBA,GAFoB,IAEdoC,QAFU,KAFd,GAOpB,GA6I+BrB,mBAAoBqC,EAAqBpD,EAAKC,IAC9Ca,eAAgByC,EAAiBvD,EAAKC,IACtCgB,SAAU8C,EAAW/D,EAAKC,WA3JnC,IAACA,CAiJP,GADWD,EAAKC,GAkB5B,IAEL,OACI,gCACI,sBAAKwB,UAAU,YAAf,UACI,wBAAQa,KAAK,SAASb,UAAU,cAAcM,QAnMvC,WACfpG,GAAY,SAAAD,GACR,IAAIuE,EAAKyB,KAAKwD,MAAsB,IAAhBxD,KAAKyD,UAEzB,OAAO,2BACAzJ,GADP,IAEIkE,MAAM,CACF,CACIK,KACAmC,KAAM,GACNhB,WAAY,KACZkC,SAAS,IALZ,mBAOE5H,EAAMkE,SAGpB,IAEDvF,OAAO+K,YAAW,WAAO,IAAD,EAEpB,UAAAC,SAASC,cAAc,sBAAvB,SAAuCC,OAC1C,GAAC,EACL,EA6KW,eACC,IACD,uBAAOjD,KAAK,OAAO7G,MAAOiH,EAAQ8C,YAAY,YAAYnD,SA7KjD,SAACL,GAClBW,EAAUX,EAAGC,OAAOxG,MACvB,IA4KY,IACD,wBAAQ6G,KAAK,SAASb,UAAU,cAAcM,QAAS,kBAAM0D,MAxN9D,6ZAwNwD,EAAvD,eACC,IACD,sBAAMhE,UAAW,iCAAmCxG,EAAQ2G,MAAO3G,EAAnE,uBAEJ,cAAC,IAAD,CAAiByK,UAvDR,SAACC,EAAoBd,GAClC,IAAMe,EAASD,EAAOC,OAChBC,EAAcF,EAAOE,YAEL,SAAlBF,EAAOG,aAAqCzC,IAAhBwC,GAC5BlK,GAAY,SAAAD,GACR,IAAMqK,EAAcrK,EAAMkE,MAAMoG,WAAU,SAAAC,GAAC,OAAIA,IAAMjC,EAAc4B,EAAOzB,MAA/B,IACrC+B,EAAmBxK,EAAMkE,MAAMoG,WAAU,SAAAC,GAAC,OAAIA,IAAMjC,EAAc6B,EAAY1B,MAApC,IAE1CvE,EAAK,YAAOlE,EAAMkE,OAJP,EAKOA,EAAMuG,OAAOJ,EAAa,GAA3CK,EALU,oBAQjB,OAFAxG,EAAMuG,OAAOD,EAAkB,EAAGE,GAE3B,2BAAK1K,GAAZ,IAAmBkE,SACtB,GAER,EAuCO,SACI,cAAC,IAAD,CAAWyG,YAAY,QAAvB,SACK,SAACxB,GAAD,OACG,gDAASA,EAASyB,gBAAlB,IAAkCnE,IAAK0C,EAAS3D,SAAhD,UACKtB,EACAiF,EAASW,eAHjB,QAUpB,CC7OD,SAASe,EAAeC,GACpB,IAAIC,EAAU/E,KAAKwD,MAAMsB,EAASjF,GAAG,YAErC,OAAIkF,EAAU,GACJ,GAAN,OAAUA,EAAV,KACOA,EAAU,KAAO,EAClB,GAAN,OAAU/E,KAAKwD,MAAMuB,EAAU,IAA/B,KAEM,GAAN,OAAU/E,KAAKwD,MAAMuB,EAAU,IAA/B,YAAsCA,EAAU,GAAhD,IAEP,CAuBc,SAASC,EAAT,GAA8C,IAAvBC,EAAsB,EAAtBA,YAC1BjL,EAAUL,cAAVK,MAEFkH,EAAU7H,IAAM8H,SAAQ,kBAAMlD,EAAmBjE,EAAMkE,MAA/B,GAAuC,CAAClE,EAAMkE,QACtEgH,EAAa7L,IAAM8H,SAAQ,kBAzBrC,SAA0BE,EAAiB4D,GACvC,IAAIE,EAAYF,EAAYG,MAAM,QAClC,OAAO/D,EAAOL,QAAO,SAAAM,GAAK,OAAIA,EAAMc,YAAc6C,GAAe3D,EAAMc,YAAc+C,CAA3D,GAC7B,CAsB0CE,CAAiBrL,EAAMqH,OAAQ4D,EAArC,GAAmD,CAACjL,EAAMqH,OAAQ4D,IAC7FK,EArBV,SAA2BjE,GACvB,IADwC,EACpCkE,EAAyC,CAAC,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,GAD/B,cAGtBlE,GAHsB,IAGxC,2BAA0B,CAAC,IAAD,IAAjBC,EAAiB,QAClBkE,EAAMD,EAAKjE,EAAMc,WAAWqD,QAAQ,GACpCC,GAAgBpE,EAAMW,UAAYC,WAASC,SAASY,KAAKzB,EAAMc,YACnEoD,EAAIlE,EAAMC,QAAV,oBAAoBiE,EAAIlE,EAAMC,eAA9B,aAAoB,EAAmBuB,KAAK4C,UAA5C,QAA6DA,CAChE,CAPuC,+BASxC,OAAOH,CACV,CAWmBI,CAAkBT,GAElC,OACI,qBAAKnF,UAAU,YAAf,SACKuF,EAAQjH,KAAI,SAACmH,EAAK/C,GAAN,OACT,sBAAK1C,UAAU,WAAf,UACI,qBAAKA,UAAU,gBAAf,SAA0CkF,EAAYnC,KAAK,CAAE8C,KAAMnD,IAASoD,SAAS,SAAlD,OAClC1H,OAAO2H,QAAQN,GAAKnH,KAAI,mCAAEkD,EAAF,KAAUuD,EAAV,YACrB,sBAAK/E,UAAU,gBAAf,UACI,qBAAKA,UAAU,qBAAf,SAAqCmB,EAAQK,GAAyBb,OACtE,qBAAKX,UAAU,qBAAf,SAAqC8E,EAAeC,OAFpBvD,EADf,IAMxBpD,OAAO4H,KAAKP,GAAKxD,OAAS,EAEnB,qBAAKjC,UAAU,oBAAf,SAAoC8E,EAAe1G,OAAO6H,OAAOR,GAAKS,QAAO,SAACC,EAAKC,GAAN,OAAeD,EAAIpD,KAAKqD,EAAxB,OAE/E,OAZqBlB,EAAYmB,WAAa,IAAM3D,EADrD,KAmBxB,C,WC5DD,SAASoC,EAAeC,GACpB,IAAIC,EAAU/E,KAAKwD,MAAMsB,EAASjF,GAAG,YAErC,OAAIkF,EAAU,GACJ,GAAN,OAAUA,EAAV,KACOA,EAAU,KAAO,EAClB,GAAN,OAAU/E,KAAKwD,MAAMuB,EAAU,IAA/B,KAEM,GAAN,OAAU/E,KAAKwD,MAAMuB,EAAU,IAA/B,YAAsCA,EAAU,GAAhD,IAEP,CA2Cc,SAASsB,EAAT,GAA+C,IAAvBpB,EAAsB,EAAtBA,YAC3BjL,EAAUL,cAAVK,MAEFkH,EAAU7H,IAAM8H,SAAQ,kBAAMlD,EAAmBjE,EAAMkE,MAA/B,GAAuC,CAAClE,EAAMkE,QACtEgH,EAAa7L,IAAM8H,SAAQ,kBA7CrC,SAA0BE,EAAiB4D,GACvC,IAAIE,EAAYF,EAAYG,MAAM,QAClC,OAAO/D,EAAOL,QAAO,SAAAM,GAAK,OAAIA,EAAMc,YAAc6C,GAAe3D,EAAMc,YAAc+C,CAA3D,GAC7B,CA0C0CE,CAAiBrL,EAAMqH,OAAQ4D,EAArC,GAAmD,CAACjL,EAAMqH,OAAQ4D,IAC7FM,EAzCV,SAAwBlE,GACpB,IADqC,EACjCkE,EAAkB,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IADV,cAGnBlE,GAHmB,IAGrC,2BAA0B,CAAC,IAAlBC,EAAiB,QACtBiE,EAAKjE,EAAMc,WAAWqD,QAAQ,GAAGjE,KAAKF,EACzC,CALoC,+BAOrC,OAAOiE,CACV,CAiCgBe,CAAepB,GAE5B,OACI,sBAAKnF,UAAU,0BAAf,UACI,8BACKwG,gBAAM,EAAG,IAAIlI,KAAI,SAAAmI,GAAI,OAClB,qBAAgBzG,UAAU,YAA1B,SAAuCyG,GAA7BA,EADQ,MAI1B,qBAAKzG,UAAU,+BAAf,SACKwF,EAAKlH,KAAI,SAACgD,EAAQoB,GAAT,OACN,sBAAK1C,UAAU,WAAf,UACI,qBAAKA,UAAU,gBAAf,SAA0CkF,EAAYnC,KAAK,CAAE8C,KAAMnD,IAASoD,SAAS,SAAlD,OAEnC,qBAAK9F,UAAU,kBAAf,SACKsB,EAAOhD,KAAI,SAACiD,EAAOmB,GAChB,IA/CXgE,EA+CeC,EAAsC,MA/CrDD,EA+CiCnF,EAAMc,YA9C5CW,KAAK0D,EAAKE,QAAQ,QAAQ9G,GAAG,WAAlC,OA+CyB+G,EAAmE,IA5CvG,SAA+BC,EAAiBC,GAC5C,IAAMC,EAAOD,GAAO5E,WAASC,QAE7B,OAAK0E,EAAMzB,MAAM,OAAO4B,OAAOD,EAAK3B,MAAM,QAG/B2B,EAAKhE,KAAK8D,GAAOhH,GAAG,WAApB,MAFAgH,EAAMzB,MAAM,OAAOrC,KAAK8D,GAAOhH,GAAG,WAAlC,KAId,CAoC4CoH,CAAsB3F,EAAMc,WAAYd,EAAMW,UACvDiF,EAnCpC,SAA8BN,GAK1B,OAAO5G,KAAKI,IAAIJ,KAAKwD,OAAOoD,EAJZ,GACG,IACF,IAE6D,EACjF,CA6B2CO,CAAqBP,GACjC,OACI,qBACI7G,UAAU,aAEVqD,MAAO,CAAEsD,MAAKE,UACd1G,MAAOgB,EAAQI,EAAMC,QAAQb,KAAO,MAAQmE,GAAgBvD,EAAMW,UAAYC,WAASC,SAASY,KAAKzB,EAAMc,aAJ/G,SAMI,qBACIrC,UAAU,qBACVqD,MAAO,CAACgE,gBAAiBF,GAAS,QAFtC,SAIKA,EAAQ,EAAIhG,EAAQI,EAAMC,QAAyBb,KAAO,MAR1DwC,OAAO5B,EAAMC,QAAU2B,OAAOT,GAY9C,QAvBsBwC,EAAYmB,WAAa,IAAM3D,EADxD,QA+BzB,C,MClGM,SAAS4E,IAAQ,IAAD,EACmBhO,IAAMM,SAASuI,WAASC,QAAQwE,QAAQ,SAD3D,mBACZ1B,EADY,KACCqC,EADD,OAEKjO,IAAMM,SAA+B,WAF1C,mBAEZ4N,EAFY,KAENC,EAFM,KAgBnB,OACI,gCACI,sBAAKzH,UAAU,cAAf,UACI,wBAAQA,UAAU,eAAea,KAAK,SAASP,QAfvC,WAChBiH,EAAerC,EAAYwC,MAAM,CAAEC,MAAO,IAC7C,EAaW,eACA,sBAAM3H,UAAU,aAAhB,SAA8BkF,EAAYY,SAAS,YAAc,MAAQZ,EAAYG,MAAM,QAAQS,SAAS,cAC5G,wBAAQ9F,UAAU,cAAca,KAAK,SAASP,QAbnC,WACnBiH,EAAerC,EAAYnC,KAAK,CAAE4E,MAAO,IAC5C,EAWW,eACC,IACD,wBAAQ3H,UAAU,cAAca,KAAK,SAASP,QAXvC,WACfmH,EAAiB,YAATD,EAAqB,WAAa,UAC7C,EASW,uBAEJ,gCACc,YAATA,GAAsB,cAACvC,EAAD,CAAaC,YAAaA,IACvC,aAATsC,GAAuB,cAAClB,EAAD,CAAcpB,YAAaA,SAIlE,CClCM,SAAS0C,IAAM,MAEMtO,IAAMuO,YAAW,iBAAO,CAAC,CAAR,GAAY,CAAC,GAA7CC,EAFS,oBAclB,OAVAxO,IAAMyD,WAAU,WACZ,IAAMI,EAAWvE,OAAOwE,YAAY0K,EAAa,KACjD,OAAO,kBAAMlP,OAAO2E,cAAcJ,EAA3B,CACV,GAAE,IAEH7D,IAAMyD,WAAU,WAEZ,OADAnE,OAAOqE,iBAAiB,QAAS6K,GAC1B,kBAAMlP,OAAOsE,oBAAoB,QAAS4K,EAA1C,CACV,GAAE,IAGC,sBAAK9H,UAAU,MAAf,UACI,cAACgB,EAAD,IACA,cAACsG,EAAD,MAGX,C,kCCxBD,qGAcAS,EAAOC,IAAM,SAAaC,GAEtB,OADA3L,QAAQ4L,IAAID,GACLA,CACV,EAEDE,IAASC,OACL,cAAC,IAAMC,WAAP,UACI,cAAC,IAAD,UACI,cAAC,IAAD,UACI,cAAC,IAAD,UAIZzE,SAAS0E,eAAe,SAM5B5K,a,sUCiBM6K,EAAsB,CACxBpK,MAAO,GACPmD,OAAQ,GACRS,WAAY,KACZyG,SAAU,CACNC,eAAgB7F,WAASC,WAAW,CAAE6F,MAAO,IAC7CC,qBAAsB,GAE1B1M,QAAS,GAGP2M,EAAetP,IAAMC,cAAc,CAAEU,MAAOsO,EAAcrO,YAAa,WAAQ,IAE9E,SAASwC,EAAezC,GAC3B,OAAOlB,KAAKI,UAAUc,EACzB,CAEM,SAAS2B,EAAiBiN,GAC7B,IAAIC,EAAM/P,KAAKC,MAAM6P,GAIrB,GAAoB,IAAhBC,EAAI7M,QACJ,MAAM,IAAIb,MAAJ,wCAA2C0N,EAAI7M,QAA/C,uBAgBV,OAbY,2BACL6M,GADK,IAERxH,OAAQwH,EAAIxH,OAAOhD,KAAI,SAACkG,GAAD,mBAAC,eACjBA,GADgB,IAEnBnC,WAAYF,WAAS4G,QAAQvE,EAAEnC,YAC/BH,SAAUsC,EAAEtC,UAAYC,WAAS4G,QAAQvE,EAAEtC,WAHxB,IAKvBsG,SAAS,2BACFM,EAAIN,UADH,IAEJC,eAAgB7F,WAASmG,QAAQD,EAAIN,SAASC,mBAKzD,CAED,SAASO,IACL,IAAI/O,EAAQrB,OAAOC,aAAaC,QAAQ,SACxC,OAAImB,EACO2B,EAAiB3B,IAE5BgP,EAAaV,GACNA,EACV,CAED,SAASU,EAAahP,GAClBrB,OAAOC,aAAaK,QAAQ,QAASwD,EAAezC,GACvD,CAEM,SAASiP,EAAcxP,GAA2B,IAC7CC,EAAaD,EAAbC,SAD4C,EAE1BL,IAAMM,SAASoP,GAFW,mBAE7C/O,EAF6C,KAEtCkP,EAFsC,KAG9CC,EAAW9P,IAAMc,OAAOH,GACxBoP,EAAW/P,IAAMc,QAAO,GACxBkP,EAAsBhQ,IAAMc,OAAyC,MAG3Ed,IAAMyD,WAAU,WAYZ,OAXAuM,EAAoB1O,QAAU2B,oBAC1B,WAEQ8M,EAASzO,UACTqO,EAAaG,EAASxO,SACtByO,EAASzO,SAAU,EAE1B,GArH0B,IAuH3B,CAAEiC,UAAU,EAAMC,SAAS,IAExB,kCAAMwM,EAAoB1O,eAA1B,aAAM,EAA6B4B,QAAnC,CACV,GAAE,IAGHlD,IAAMyD,WAAU,WACZ,IAAMwM,EAAe,WAEbF,EAASzO,UACTqO,EAAaG,EAASxO,SACtByO,EAASzO,SAAU,EAE1B,EACK4O,EAAO,WAELH,EAASzO,UACTqO,EAAaG,EAASxO,SACtByO,EAASzO,SAAU,EAE1B,EAGD,OAFAhC,OAAOqE,iBAAiB,eAAgBsM,GACxC3Q,OAAOqE,iBAAiB,OAAQuM,GACzB,WACH5Q,OAAOsE,oBAAoB,eAAgBqM,GAC3C3Q,OAAOsE,oBAAoB,OAAQsM,EACtC,CACJ,GAAE,IAUH,OACI,cAACZ,EAAa7O,SAAd,CAAuBC,MAAO,CAAEC,QAAOC,YATvB,SAACuP,GAAyC,IAAD,EACrDC,EAAWD,EAAexP,GAC9BmP,EAASxO,QAAU8O,EACnBL,EAASzO,SAAU,EACnBuO,EAASO,GACT,UAAAJ,EAAoB1O,eAApB,cAAA0O,EACH,GAGG,SACK3P,GAGZ,CAEM,SAASC,IACZ,OAAON,IAAMmE,WAAWmL,EAC3B,C","file":"static/js/main.437b1a02.chunk.js","sourcesContent":["import { debounce, DebouncedFunc } from 'lodash';\nimport React from 'react';\nimport { deserializeState, serializeState, State, useState } from './state';\n\n// How much time must pass after resync to initiate another resync.\nconst RESYNC_INTERVAL_MS = 2 * 60 * 1000;\n\n// How often to check if it's time for resync.\nconst RESYNC_CHECK_INTERVAL_MS = 5 * 1000;\n\n// How much time to wait (for more updates) before sending state to the server.\nconst UPDATE_DEBOUNCE_WAIT_MS = 1 * 1000;\n\n// Data necessary for saving state on a server.\nexport type Sync = {\n    // URL of the sync server, without trailing slash, e.g. 'http://localhost:8000'.\n    storageUrl: string,\n    // JWT auth token that will be passed to the server in 'Authorization: Bearer (TOKEN)` header.\n    authToken: string,\n    // Version of the state stored on a client.\n    version: number,\n    // Whether state has been modified since the last successful save.\n    dirty: boolean,\n    // Whether the client is currently saving state on the server.\n    saving: boolean,\n};\n\nexport type OptionalSync = Sync | null;\n\nexport type Status = 'off' | 'syncing' | 'synced' | 'dirty' | 'error';\n\n// By default syncing is disabled.\nexport const initialSync: OptionalSync = null;\n\nexport function serializeSync(sync: OptionalSync): string {\n    return JSON.stringify(sync);\n}\n\nexport function deserializeSync(syncString: string): OptionalSync {\n    let obj = JSON.parse(syncString);\n    return obj;\n}\n\nfunction sendStateToServer(state: State, sync: Sync): Promise<number> {\n    return fetch(`${sync.storageUrl}/string/${sync.version + 1}`, {\n        method: 'PUT',\n        body: serializeState(state),\n        headers: {\n            'Authorization': `Bearer ${sync.authToken}`,\n        },\n    })\n        .catch(_error => {\n            throw new Error(`Request to store app state failed`);\n        })\n        .then(response => {\n            if (response.status === 200) {\n                return sync.version + 1;\n            }\n            else if (response.status === 401) {\n                throw new Error('Unauthorized. Check authToken.');\n            }\n            else if (response.status === 409) {\n                throw new Error('Conflict detected. You will have to resolve it manually.');\n            }\n            else {\n                throw new Error(`Unexpected response status ${response.status}`);\n            }\n        });\n}\n\nfunction getStateFromServer(sync: Sync): Promise<[number, State] | null> {\n    return fetch(`${sync.storageUrl}/string`, {\n        method: 'GET',\n        headers: {\n            'Authorization': `Bearer ${sync.authToken}`,\n        },\n    })\n        .catch(_error => {\n            throw new Error(`Request to get app state failed`);\n        })\n        .then(response => {\n            if (response.status === 200) {\n                return response\n                    .text()\n                    .then(text => {\n                        let newlineIndex = text.indexOf('\\n');\n                        let version = Number(text.substring(0, newlineIndex));\n                        let state = deserializeState(text.substring(newlineIndex + 1));\n                        return [version, state] as [number, State];\n                    });\n            }\n            else if (response.status === 401) {\n                throw new Error('Unauthorized. Check authToken.');\n            }\n            else if (response.status === 404) {\n                return null;\n            }\n            else {\n                throw new Error(`Unexpected response status ${response.status}`);\n            }\n        });\n}\n\nfunction retrieveSync(): OptionalSync {\n    let sync = window.localStorage.getItem('sync');\n    if (sync) {\n        return deserializeSync(sync);\n    }\n    persistSync(initialSync);\n    return initialSync;\n}\n\nfunction persistSync(sync: OptionalSync) {\n    window.localStorage.setItem('sync', serializeSync(sync));\n}\n\nconst syncContext = React.createContext({ status: 'off' as Status });\n\nexport function SyncProvider(props: { children: any }) {\n    let { children } = props;\n    let [sync] = React.useState(retrieveSync);\n\n    return (\n        (sync !== null)\n            ? (<SyncProviderInner initSync={sync}>{children}</SyncProviderInner>)\n            : (<syncContext.Provider value={{ status: 'off' }}>{children}</syncContext.Provider>)\n    );\n}\n\nexport function SyncProviderInner(props: { initSync: Sync, children: any }) {\n    const { initSync, children } = props;\n\n    const { state, updateState } = useState();\n    const latestStateRef = React.useRef(state);\n\n    const syncRef = React.useRef(initSync);\n\n    // Ref to function that should be called whenever state changes.\n    // When it's null we're syncing with server.\n    const handleStateUpdateRef = React.useRef<DebouncedFunc<() => void> | null>(null);\n\n    // Status to share in context.\n    const [status, setStatus] = React.useState<Status>('off');\n\n    // Ref to time of the last resync attempt.\n    const lastResyncRef = React.useRef(new Date());\n\n    // Ref saying whether the component is still mounted.\n    const mountedRef = React.useRef(true);\n\n    // Ref to function that syncs state with server and initializes update handler.\n    const syncWithServerRef = React.useRef(() => {\n        if (!mountedRef.current) return;\n\n        setStatus('syncing');\n        getStateFromServer(syncRef.current)\n            .then(versionAndState => {\n                if (!mountedRef.current) return;\n\n                if (versionAndState) {\n                    const [serverVersion, serverState] = versionAndState;\n\n                    // Optimistically assume server handled \"saving\" successfully.\n                    if (syncRef.current.saving) {\n                        syncRef.current.saving = false;\n                        syncRef.current.version += 1;\n\n                        // If the server is behind, \"saving\" did not succeed.\n                        if (syncRef.current.version > serverVersion) {\n                            syncRef.current.dirty = true;\n                            syncRef.current.version -= 1;\n                        }\n                    }\n\n                    // Server is behind, it's probably a bug in client\n                    if (syncRef.current.version > serverVersion) {\n                        throw new Error(\"Server is behind client. Either a bug or storage rollback.\");\n                    }\n                    // Client and server are on the same version.\n                    // No other client has modified state when we weren't looking.\n                    else if (syncRef.current.version === serverVersion) {\n                        // Ok.\n                    }\n                    // Client is behind server and we can fast forward because state isn't dirty.\n                    else if (syncRef.current.version < serverVersion && !syncRef.current.dirty) {\n                        syncRef.current.version = serverVersion;\n\n                        latestStateRef.current = serverState;\n                        updateState(() => serverState);\n                    }\n                    // Client is behind but state is dirty so we can't fast forward.\n                    else {\n                        throw new Error(\"State is dirty and can not be fast-forwarded.\")\n                    }\n                }\n            })\n            .then(() => {\n                if (!mountedRef.current) return;\n\n                persistSync(syncRef.current);\n\n                handleStateUpdateRef.current = createStateUpdateHandler();\n                if (syncRef.current.dirty) {\n                    // if there are changes waiting, send them immediately\n                    handleStateUpdateRef.current?.();\n                    handleStateUpdateRef.current?.flush();\n                } else {\n                    setStatus('synced');\n                }\n            })\n            .catch(error => {\n                if (!mountedRef.current) return;\n\n                setStatus('error');\n                console.error(\"Initializing sync failed.\");\n                console.error(error);\n            });\n    });\n\n    // Debounce saving state on every change.\n    function createStateUpdateHandler() {\n        return debounce(\n            () => {\n                if (!mountedRef.current) return;\n\n                // stop update handler\n                handleStateUpdateRef.current?.cancel();\n                handleStateUpdateRef.current = null;\n\n                syncRef.current.saving = true;\n                syncRef.current.dirty = false;\n                persistSync(syncRef.current);\n                setStatus('syncing');\n\n                return sendStateToServer(latestStateRef.current, syncRef.current)\n                    .then(version => {\n                        if (!mountedRef.current) return;\n\n                        syncRef.current.saving = false;\n                        syncRef.current.version = version;\n                        persistSync(syncRef.current);\n\n                        handleStateUpdateRef.current = createStateUpdateHandler();\n                        if (syncRef.current.dirty) {\n                            handleStateUpdateRef.current?.();\n                            setStatus('dirty');\n                        } else {\n                            setStatus('synced');\n                        }\n                    })\n                    .catch(error => {\n                        if (!mountedRef.current) return;\n\n                        let becameDirty = syncRef.current.dirty;\n\n                        syncRef.current.saving = false;\n                        syncRef.current.dirty = true;\n                        persistSync(syncRef.current);\n\n                        console.error(\"Failed to send state to server.\");\n                        console.error(error);\n\n                        handleStateUpdateRef.current = createStateUpdateHandler();\n                        if (becameDirty) {\n                            handleStateUpdateRef.current?.();\n                            setStatus('dirty');\n                        } else {\n                            setStatus('error');\n                        }\n                    });\n            },\n            UPDATE_DEBOUNCE_WAIT_MS,\n            { trailing: true, leading: false },\n        );\n    }\n\n    // react to change of state\n    React.useEffect(() => {\n        // if state change was not caused by fetch\n        if (state !== latestStateRef.current) {\n            latestStateRef.current = state;\n\n            if (!syncRef.current.dirty) {\n                syncRef.current.dirty = true;\n                persistSync(syncRef.current);\n\n                // set status to dirty only if we aren't currently syncing\n                if (handleStateUpdateRef.current !== null) {\n                    setStatus('dirty');\n                }\n            }\n\n            handleStateUpdateRef.current?.();\n        }\n    }, [state]);\n\n    // sync with server on focus\n    React.useEffect(() => {\n        const resync = () => {\n            // resync only if we aren't syncing\n            if (handleStateUpdateRef.current !== null) {\n                handleStateUpdateRef.current.cancel();\n                handleStateUpdateRef.current = null;\n\n                syncWithServerRef.current();\n\n                lastResyncRef.current = new Date();\n            }\n        };\n        window.addEventListener('focus', resync);\n        return () => window.removeEventListener('focus', resync);\n    }, []);\n\n    // sync with server if last sync was more than 10 minutes ago\n    React.useEffect(() => {\n        const resync = () => {\n            let now = new Date();\n            // resync only if we aren't syncing and more than RESYNC_INTERVAL_MS passed\n            if (handleStateUpdateRef.current !== null && now.getTime() - lastResyncRef.current.getTime() > RESYNC_INTERVAL_MS) {\n                handleStateUpdateRef.current.cancel();\n                handleStateUpdateRef.current = null;\n\n                syncWithServerRef.current();\n\n                lastResyncRef.current = now;\n            }\n        };\n\n        const interval = window.setInterval(resync, RESYNC_CHECK_INTERVAL_MS);\n        return () => window.clearInterval(interval);\n    }, []);\n\n    // start and stop syncing\n    React.useEffect(() => {\n        syncWithServerRef.current();\n        return () => {\n            mountedRef.current = false;\n            handleStateUpdateRef.current?.cancel();\n            handleStateUpdateRef.current = null;\n        };\n    }, []);\n\n    return (\n        <syncContext.Provider value={{ status }}>\n            {children}\n        </syncContext.Provider>\n    );\n}\n\nexport function useSync() {\n    return React.useContext(syncContext);\n}\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import { DateTime, Duration } from \"luxon\";\nimport { MouseEvent } from \"react\";\nimport { Event, Task } from \"./state\";\n\nexport function groupTasksByTaskId(tasks: Task[]): { [taskId: number]: Task } {\n    return Object.fromEntries(tasks.map(task => [task.id, task]));\n}\n\nexport function groupEventsByTaskId(events: Event[]): { [taskId: number]: Event[] } {\n    let story: { [taskId: number]: Event[] } = {};\n\n    for (let event of events) {\n        if (story[event.taskId]) {\n            story[event.taskId].push(event);\n        } else {\n            story[event.taskId] = [event];\n        }\n    }\n\n    return story;\n}\n\nexport function calculateTotalTimeFromEvents(events: Event[]): Duration {\n    let totalTime = Duration.fromObject({ seconds: 0 });\n\n    events.forEach(event => {\n        totalTime = totalTime.plus((event.end_time || DateTime.local()).diff(event.start_time));\n    });\n\n    return totalTime;\n}\n\nexport function cs(...classes: (string | false)[]): string {\n    let output = \"\";\n    classes.forEach(c => {\n        if (c !== false) {\n            output = output + \" \" + c;\n        }\n    });\n    return output;\n}\n\nexport function assert(condition: boolean): void {\n    if (!condition) {\n        console.error(\"assertion failed!\");\n        console.trace();\n        throw new Error(\"assertion failed\");\n    }\n}\n\nexport const onlyThisElementClick = (fn: (ev: MouseEvent) => void) => (ev: MouseEvent) => {\n    if (ev.target === ev.currentTarget) {\n        fn(ev);\n    }\n}\n","import { Duration } from 'luxon';\nimport { ManDays, Task as TaskModel } from './state';\nimport { cs, onlyThisElementClick } from './utils';\nimport './task.css';\n\nconst HOURS_IN_ONE_MAN_DAY = 7;\n\ntype TaskProps = {\n    task: TaskModel,\n    active: boolean,\n    timeSpent: Duration,\n    onActiveChange: (active: boolean) => void,\n    onEstimationChange: (estimation: ManDays | null) => void,\n    onNameChange: (name: string) => void,\n    onDelete: () => void,\n    innerRef?: React.Ref<HTMLDivElement>,\n};\n\nexport function Task({ task, active, timeSpent, onActiveChange, onEstimationChange, onNameChange, onDelete, innerRef }: TaskProps) {\n\n    const updateName = (ev: any) => {\n        onNameChange(ev.target.value);\n    };\n\n    const toggleActive = () => {\n        onActiveChange(!active);\n    }\n\n    const updateEstimation = (ev: any) => {\n        onEstimationChange(Number(ev.target.value) || null);\n    };\n\n    const incrementEstimation = () => {\n        onEstimationChange((task.estimation || 0) + 1);\n    };\n\n    const decrementEstimation = () => {\n        onEstimationChange(((task.estimation || 1) - 1) || null);\n    };\n\n    let timeSpentElement = null;\n\n    if (task.estimation !== null) {\n        let estimationSpent = timeSpent.as('hours') / HOURS_IN_ONE_MAN_DAY;\n        let estimationRatio = estimationSpent / task.estimation;\n        let estimationClassName;\n\n             if (estimationRatio < 0.5) estimationClassName = 'ok';\n        else if (estimationRatio < 0.7) estimationClassName = 'worse';\n        else if (estimationRatio < 0.9) estimationClassName = 'bad';\n        else                            estimationClassName = 'critical';\n\n        timeSpentElement = (\n            <span>\n                Time:\n                {\" \"}\n                <progress\n                    className={cs(estimationClassName)}\n                    value={Math.min(estimationRatio, 1.0)}\n                    title={`${estimationSpent.toFixed(1)} of ${task.estimation} man days`}\n                    max=\"1\"\n                />\n            </span>\n        );\n    }\n\n    return (\n        <div\n            className={cs(\"task\", active && \"active\")}\n            key={task.id}\n            onClick={onlyThisElementClick(toggleActive)}\n            ref={innerRef}\n        >\n            <div><textarea className=\"name\" value={task.name} onChange={updateName}/></div>\n            <div>{\"Estimation: \"}\n                <button type=\"button\" className=\"button minus\" onClick={decrementEstimation}>-</button>\n                {\" \"}\n                <input\n                    className=\"estimation\"\n                    min=\"1\"\n                    step=\"1\"\n                    type=\"number\"\n                    value={task.estimation || \"\"}\n                    onChange={updateEstimation}\n                />\n                {\" \"}\n                <button type=\"button\" className=\"button plus\" onClick={incrementEstimation}>+</button>\n                {\" \"}\n                {timeSpentElement}\n                {\" \"}\n                <button type=\"button\" className=\"button\" onClick={() => window.confirm(\"You sure?\") && onDelete()}>Delete</button>\n            </div>\n        </div>\n    );\n}\n","import React from 'react';\nimport { DateTime } from 'luxon';\nimport { DragDropContext, Draggable, Droppable, DropResult, ResponderProvided } from 'react-beautiful-dnd';\nimport { ManDays, TaskId, useState } from './state';\nimport { Task } from './task';\nimport { assert, groupEventsByTaskId, groupTasksByTaskId, calculateTotalTimeFromEvents } from './utils';\nimport { useSync } from './sync';\n\nimport './tasks.css';\n\nconst ALERT_MSG = `\nGood day!\n\nThis is a small app for time tracking. It's serverless, meaning all data is stored on your device, in local storage*. As you can see, it's pretty basic and not well tested. Probably works only on Firefox. Use it at your own risk.\n\n* You can enable syncing through a self-hosted backend, more on that in README.md at https://github.com/prk3/suckless-time-tracker.\n\nsuckless-time-tracker 0.4.0`;\n\nexport function Tasks() {\n    const { state, updateState } = useState();\n    const { status } = useSync();\n    const [filter, setFilter] = React.useState('');\n\n    let taskMap = React.useMemo(() => groupTasksByTaskId(state.tasks), [state.tasks]);\n    let story = React.useMemo(() => groupEventsByTaskId(state.events), [state.events]);\n\n    const addNewTask = () => {\n        updateState(state => {\n            let id = Math.floor(Math.random() * 1_000_000_000);\n\n            return {\n                ...state,\n                tasks: [\n                    {\n                        id,\n                        name: \"\",\n                        estimation: null,\n                        deleted: false,\n                    },\n                    ...state.tasks,\n                ],\n            };\n        });\n        // Focus on the new task.\n        window.setTimeout(() => {\n            // @ts-ignore\n            document.querySelector(\".task .name\")?.focus();\n        },1);\n    };\n\n    const updateFilter = (ev: any) => {\n        setFilter(ev.target.value);\n    };\n\n    const updateTaskName = (id: TaskId) => (name: string) => {\n        // Task must exist and not be deleted.\n        assert(taskMap[id] !== undefined);\n        assert(taskMap[id].deleted === false);\n\n        updateState(state => ({\n            ...state,\n            tasks: state.tasks.map(task => task.id !== id\n                ? task\n                : { ...task, name }\n            ),\n        }));\n    };\n\n    const updateTaskEstimation = (id: TaskId) => (estimation: ManDays | null) => {\n        // Task must exist and not be deleted.\n        assert(taskMap[id] !== undefined);\n        assert(taskMap[id].deleted === false);\n\n        updateState(state => ({\n            ...state,\n            tasks: state.tasks.map(task => task.id !== id\n                ? task\n                : { ...task, estimation }\n            ),\n        }));\n    };\n\n    const updateTaskActive = (id: TaskId) => (active: boolean) => {\n        // Task must exist and not be deleted.\n        assert(taskMap[id] !== undefined);\n        assert(taskMap[id].deleted === false);\n\n        updateState(state => {\n            if (active) {\n                // Task must be inactive if we want to activate it.\n                assert(state.activeTask !== id);\n\n                let newEvents = [...state.events];\n\n                if (state.activeTask !== null) {\n                    assert(newEvents.length > 0);\n                    assert(newEvents[newEvents.length - 1].end_time === null);\n                    newEvents[newEvents.length - 1] = {\n                        ...newEvents[newEvents.length - 1],\n                        end_time: DateTime.local(),\n                    };\n                }\n                newEvents.push({\n                    taskId: id,\n                    start_time: DateTime.local(),\n                    end_time: null,\n                });\n\n                return {\n                    ...state,\n                    activeTask: id,\n                    events: newEvents,\n                };\n            } else {\n                // Task must be active if we want to deactivate it.\n                assert(state.activeTask === id);\n\n                let newEvents = [...state.events];\n\n                assert(newEvents.length > 0);\n                assert(newEvents[newEvents.length - 1].end_time === null);\n\n                newEvents[newEvents.length - 1] = {\n                    ...newEvents[newEvents.length - 1],\n                    end_time: DateTime.local(),\n                };\n\n                return {\n                    ...state,\n                    activeTask: null,\n                    events: newEvents,\n                };\n            }\n        });\n    };\n\n    const deleteTask = (id: TaskId) => () => {\n        // Task must exist and not be deleted.\n        assert(taskMap[id] !== undefined);\n        assert(taskMap[id].deleted === false);\n\n        updateState(state => {\n            let events;\n            let activeTask;\n            if (state.activeTask === id) {\n                events = [...state.events];\n                assert(events.length > 0);\n                assert(events[events.length - 1].end_time === null);\n                events[events.length - 1] = {\n                    ...events[events.length - 1],\n                    end_time: DateTime.local(),\n                };\n                activeTask = null;\n            } else {\n                events = state.events;\n                activeTask = state.activeTask;\n            }\n\n            return {\n                ...state,\n                tasks: state.tasks.map(task => task.id !== id\n                    ? task\n                    : { ...task, deleted: true }\n                ),\n                activeTask,\n                events,\n            };\n        });\n    };\n\n    const filteredTasks = state.tasks\n        .filter(task => !task.deleted)\n        .filter(task => filter.trim() === \"\" || task.name.includes(filter.trim()))\n\n    const moveTask = (result: DropResult, provided: ResponderProvided) => {\n        const source = result.source;\n        const destination = result.destination;\n\n        if (result.reason === 'DROP' && destination !== undefined) {\n            updateState(state => {\n                const sourceIndex = state.tasks.findIndex(e => e === filteredTasks[source.index]);\n                const destinationIndex = state.tasks.findIndex(e => e === filteredTasks[destination.index]);\n\n                const tasks = [...state.tasks];\n                const [reorderedItem] = tasks.splice(sourceIndex, 1);\n                tasks.splice(destinationIndex, 0, reorderedItem);\n\n                return { ...state, tasks };\n            });\n        }\n    };\n\n    const tasks = filteredTasks\n        .map((task, index) => {\n            let active = task.id === state.activeTask;\n            let timeSpent = calculateTotalTimeFromEvents(story[task.id] || []);\n\n            return (\n                <Draggable key={task.id} draggableId={String(task.id)} index={index}>\n                    {(provided) => (\n                        <div style={{ padding: '2.5px 5px' }}>\n                            <div {...provided.draggableProps} {...provided.dragHandleProps} ref={provided.innerRef} >\n                                <Task\n                                    task={task}\n                                    active={active}\n                                    timeSpent={timeSpent}\n                                    onNameChange={updateTaskName(task.id)}\n                                    onEstimationChange={updateTaskEstimation(task.id)}\n                                    onActiveChange={updateTaskActive(task.id)}\n                                    onDelete={deleteTask(task.id)}\n                                />\n                            </div>\n                        </div>\n                    )}\n                </Draggable>\n            );\n        });\n\n    return (\n        <div>\n            <div className=\"tasks-bar\">\n                <button type=\"button\" className=\"button plus\" onClick={addNewTask}>+</button>\n                {\" \"}\n                <input type=\"text\" value={filter} placeholder=\"Search...\" onChange={updateFilter} />\n                {\" \"}\n                <button type=\"button\" className=\"button plus\" onClick={() => alert(ALERT_MSG)}>?</button>\n                {\" \"}\n                <span className={\"sync-indicator sync-indicator-\" + status} title={status}>●</span>\n            </div>\n            <DragDropContext onDragEnd={moveTask}>\n                <Droppable droppableId=\"tasks\">\n                    {(provided) => (\n                        <div {...provided.droppableProps} ref={provided.innerRef}>\n                            {tasks}\n                            {provided.placeholder}\n                        </div>\n                    )}\n                </Droppable>\n            </DragDropContext>\n        </div>\n    );\n}\n","import React from 'react';\nimport { DateTime, Duration } from 'luxon';\nimport { Event, useState } from './state';\nimport { groupTasksByTaskId } from './utils';\n\nfunction formatDuration(duration: Duration): string {\n    let minutes = Math.floor(duration.as('minutes'));\n\n    if (minutes < 60) {\n        return `${minutes}m`;\n    } else if (minutes % 60 === 0) {\n        return `${Math.floor(minutes / 60)}h`;\n    } else {\n        return `${Math.floor(minutes / 60)}h${minutes % 60}m`;\n    }\n}\n\nfunction selectWeekEvents(events: Event[], startOfWeek: DateTime) {\n    let endOfWeek = startOfWeek.endOf('week');\n    return events.filter(event => event.start_time >= startOfWeek && event.start_time <= endOfWeek);\n}\n\nfunction weekLogFromEvents(events: Event[]) {\n    let week: { [taskId: number]: Duration }[] = [{}, {}, {}, {}, {}, {}, {}];\n\n    for (let event of events) {\n        let day = week[event.start_time.weekday-1];\n        let taskDuration = (event.end_time || DateTime.local()).diff(event.start_time);\n        day[event.taskId] = day[event.taskId]?.plus(taskDuration) ?? taskDuration;\n    }\n\n    return week;\n}\n\ntype Props = {\n    startOfWeek: DateTime,\n}\n\nexport default function WeekSummary({ startOfWeek }: Props) {\n    const { state } = useState();\n\n    const taskMap = React.useMemo(() => groupTasksByTaskId(state.tasks), [state.tasks]);\n    const weekEvents = React.useMemo(() => selectWeekEvents(state.events, startOfWeek), [state.events, startOfWeek]);\n    const weekLog = weekLogFromEvents(weekEvents);\n\n    return (\n        <div className=\"week-view\">\n            {weekLog.map((day, index) => (\n                <div className=\"week-day\" key={startOfWeek.toString() + ' ' + index}>\n                    <div className=\"week-day-name\" key=\"day\">{startOfWeek.plus({ days: index }).toFormat('cccc')}</div>\n                    {Object.entries(day).map(([taskId, duration]) => (\n                        <div className=\"week-task-log\" key={taskId}>\n                            <div className=\"week-task-log-name\">{taskMap[taskId as any as number].name}</div>\n                            <div className=\"week-task-log-time\">{formatDuration(duration)}</div>\n                        </div>\n                    ))}\n                    {Object.keys(day).length > 0\n                        ? (\n                            <div className=\"week-task-summary\">{formatDuration(Object.values(day).reduce((acc, next) => acc.plus(next)))}</div>\n                        )\n                        : null\n                    }\n                </div>\n            ))}\n        </div>\n    );\n}\n","import React from 'react';\nimport { DateTime, Duration } from 'luxon';\nimport { Event, useState } from './state';\nimport { groupTasksByTaskId } from './utils';\nimport { range } from 'lodash';\n\nfunction formatDuration(duration: Duration): string {\n    let minutes = Math.floor(duration.as('minutes'));\n\n    if (minutes < 60) {\n        return `${minutes}m`;\n    } else if (minutes % 60 === 0) {\n        return `${Math.floor(minutes / 60)}h`;\n    } else {\n        return `${Math.floor(minutes / 60)}h${minutes % 60}m`;\n    }\n}\n\nfunction selectWeekEvents(events: Event[], startOfWeek: DateTime) {\n    let endOfWeek = startOfWeek.endOf('week');\n    return events.filter(event => event.start_time >= startOfWeek && event.start_time <= endOfWeek);\n}\n\nfunction weekFromEvents(events: Event[]) {\n    let week: Event[][] = [[], [], [], [], [], [], []];\n\n    for (let event of events) {\n        week[event.start_time.weekday-1].push(event);\n    }\n\n    return week;\n}\n\nfunction topFromTime(time: DateTime) {\n    return time.diff(time.startOf('day')).as('seconds') / (24 * 60 * 60);\n}\n\nfunction heightFromStartAndEnd(start: DateTime, end: DateTime | null) {\n    const end_ = end || DateTime.local();\n\n    if (!start.endOf('day').equals(end_.endOf('day'))) {\n        return start.endOf('day').diff(start).as('seconds') / (24 * 60 * 60);\n    } else {\n        return end_.diff(start).as('seconds') / (24 * 60 * 60);\n    }\n}\n\nfunction linesCountFromHeight(height: number) {\n    let marginTop = 10;\n    let marginBottom = 10;\n    let lineHeight = 17;\n\n    return Math.max(Math.floor((height - marginTop - marginBottom) / lineHeight), 0);\n}\n\ntype Props = {\n    startOfWeek: DateTime,\n}\n\nexport default function WeekTimeline({ startOfWeek }: Props) {\n    const { state } = useState();\n\n    const taskMap = React.useMemo(() => groupTasksByTaskId(state.tasks), [state.tasks]);\n    const weekEvents = React.useMemo(() => selectWeekEvents(state.events, startOfWeek), [state.events, startOfWeek]);\n    const week = weekFromEvents(weekEvents);\n\n    return (\n        <div className=\"week-timeline-container\">\n            <div>\n                {range(0, 25).map(hour => (\n                    <div key={hour} className=\"hour-line\">{hour}</div>\n                ))}\n            </div>\n            <div className=\"week-view week-timeline-view\">\n                {week.map((events, index) => (\n                    <div className=\"week-day\" key={startOfWeek.toString() + ' ' + index}>\n                        <div className=\"week-day-name\" key=\"day\">{startOfWeek.plus({ days: index }).toFormat('cccc')}</div>\n\n                        <div className=\"week-day-events\">\n                            {events.map((event, index) => {\n                                let top = topFromTime(event.start_time) * 960;\n                                let height = heightFromStartAndEnd(event.start_time, event.end_time) * 960;\n                                let lines = linesCountFromHeight(height);\n                                return (\n                                    <div\n                                        className=\"week-event\"\n                                        key={String(event.taskId) + String(index)}\n                                        style={{ top, height }}\n                                        title={taskMap[event.taskId].name + ' - ' + formatDuration((event.end_time || DateTime.local()).diff(event.start_time))}\n                                    >\n                                        <div\n                                            className=\"week-task-log-name\"\n                                            style={{WebkitLineClamp: lines || 'none'}}\n                                        >\n                                            {lines > 0 ? taskMap[event.taskId as any as number].name : ''}\n                                        </div>\n                                    </div>\n                                );\n                            })}\n                        </div>\n                    </div>\n                ))}\n            </div>\n        </div>\n    );\n}\n","import { DateTime } from 'luxon';\nimport React from 'react';\nimport WeekSummary from './week-summary';\nimport WeekTimeline from './week-timeline';\n\nimport './week.css';\n\nexport function Week() {\n    const [startOfWeek, setStartOfWeek] = React.useState(DateTime.local().startOf('week'));\n    const [mode, setMode] = React.useState<'summary'|'timeline'>('summary');\n\n    const oneWeekBack = () => {\n        setStartOfWeek(startOfWeek.minus({ weeks: 1 }));\n    }\n\n    const oneWeekForward = () => {\n        setStartOfWeek(startOfWeek.plus({ weeks: 1 }));\n    }\n\n    const toggleMode = () => {\n        setMode(mode === 'summary' ? 'timeline' : 'summary');\n    }\n\n    return (\n        <div>\n            <div className=\"week-select\">\n                <button className=\"button minus\" type=\"button\" onClick={oneWeekBack}>&lt;</button>\n                <span className=\"week-range\">{startOfWeek.toFormat(\"d LLLL y\") + ' - ' + startOfWeek.endOf('week').toFormat(\"d LLLL y\")}</span>\n                <button className=\"button plus\" type=\"button\" onClick={oneWeekForward}>&gt;</button>\n                {\" \"}\n                <button className=\"button plus\" type=\"button\" onClick={toggleMode}>↷</button>\n            </div>\n            <div>\n                {mode === 'summary' && <WeekSummary startOfWeek={startOfWeek} />}\n                {mode === 'timeline' && <WeekTimeline startOfWeek={startOfWeek} />}\n            </div>\n        </div>\n    );\n}\n","import React from 'react';\nimport { Tasks } from './tasks';\nimport { Week } from './week';\n\nexport function App() {\n    // Force-update interface every minute when user is inactive.\n    const [, forceUpdate] = React.useReducer(() => ({}), {});\n\n    React.useEffect(() => {\n        const interval = window.setInterval(forceUpdate, 60 * 1000);\n        return () => window.clearInterval(interval);\n    }, []);\n\n    React.useEffect(() => {\n        window.addEventListener('focus', forceUpdate);\n        return () => window.removeEventListener('focus', forceUpdate);\n    }, []);\n\n    return (\n        <div className=\"App\">\n            <Tasks />\n            <Week />\n        </div>\n    );\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { App } from './App';\nimport reportWebVitals from './reportWebVitals';\nimport { StateProvider } from './state';\nimport { SyncProvider } from './sync';\n\nimport './index.css';\n\ndeclare global {\n    function dbg<T>(a: T): T;\n}\n\n// @ts-ignore\nglobal.dbg = function <T>(a: T) {\n    console.log(a);\n    return a;\n};\n\nReactDOM.render(\n    <React.StrictMode>\n        <StateProvider>\n            <SyncProvider>\n                <App />\n            </SyncProvider>\n        </StateProvider>\n    </React.StrictMode>,\n    document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n","import { debounce, DebouncedFunc } from 'lodash';\nimport { DateTime, Duration } from 'luxon';\nimport React from 'react';\n\nconst STATE_PERSIST_DEBOUNCE_WAIT_MS = 500;\n\nexport type TaskId = number;\nexport type ManDays = number;\n\n// A thing you can work on.\nexport type Task = {\n    id: TaskId,\n    name: string,\n    // If estimated, we'll be able to show time spent on the task.\n    estimation: ManDays | null,\n    // Flag hiding a task from the interface. Soft-deleted tasks will be\n    // permanently deleted when no \"start\" event has been recorded in 3 months.\n    // This makes sure that deleting a task will not destroy \"recent\" history.\n    deleted: boolean,\n}\n\n// Started or started and finished piece of work.\nexport type Event = {\n    taskId: TaskId,\n    start_time: DateTime,\n    end_time: DateTime | null,\n}\n\nexport type Settings = {\n    // How much real time one ManDay represents. Used for displaying progress\n    // on tasks.\n    manDayDuration: Duration,\n    // The app is allowed to delete events older than that many months. Progress\n    // on estimated tasks may go down.\n    eventRetentionMonths: number,\n}\n\nexport type State = {\n    tasks: Task[],\n    events: Event[],\n    activeTask: TaskId | null,\n    settings: Settings,\n    // Number identifying state format. Used for migrating.\n    version: number,\n}\n\nexport type StateUpdateFunction = (state: State) => State;\n\nexport type StateUpdate = (fn: StateUpdateFunction) => void;\n\nconst initialState: State = {\n    tasks: [],\n    events: [],\n    activeTask: null,\n    settings: {\n        manDayDuration: Duration.fromObject({ hours: 7 }),\n        eventRetentionMonths: 3,\n    },\n    version: 1,\n};\n\nconst stateContext = React.createContext({ state: initialState, updateState: () => {} } as { state: State, updateState: StateUpdate });\n\nexport function serializeState(state: State): string {\n    return JSON.stringify(state);\n}\n\nexport function deserializeState(stateString: string): State {\n    let obj = JSON.parse(stateString);\n\n    // migrations\n    // current version = 1\n    if (obj.version !== 1) {\n        throw new Error(`State in unsupported version \"${obj.version}\". Update the app.`);\n    }\n\n    let hydrated = {\n        ...obj,\n        events: obj.events.map((e: any) => ({\n            ...e,\n            start_time: DateTime.fromISO(e.start_time),\n            end_time: e.end_time && DateTime.fromISO(e.end_time)\n        })),\n        settings: {\n            ...obj.settings,\n            manDayDuration: Duration.fromISO(obj.settings.manDayDuration),\n        },\n    };\n\n    return hydrated as State;\n}\n\nfunction retrieveState(): State {\n    let state = window.localStorage.getItem('state');\n    if (state) {\n        return deserializeState(state);\n    }\n    persistState(initialState);\n    return initialState;\n}\n\nfunction persistState(state: State) {\n    window.localStorage.setItem('state', serializeState(state));\n}\n\nexport function StateProvider(props: { children: any }) {\n    const { children } = props;\n    const [state, setState] = React.useState(retrieveState);\n    const stateRef = React.useRef(state);\n    const dirtyRef = React.useRef(false);\n    const debouncedPersistRef = React.useRef<DebouncedFunc<() => void> | null>(null);\n\n    // Debounce persisting state on every change.\n    React.useEffect(() => {\n        debouncedPersistRef.current = debounce(\n            () => {\n                // Don't persist if not dirty. Maybe window blur already persisted state?\n                if (dirtyRef.current) {\n                    persistState(stateRef.current);\n                    dirtyRef.current = false;\n                }\n            },\n            STATE_PERSIST_DEBOUNCE_WAIT_MS,\n            { trailing: true, leading: false },\n        );\n        return () => debouncedPersistRef.current?.cancel();\n    }, []);\n\n    // Persist state before closing the page and on blur.\n    React.useEffect(() => {\n        const beforeunload = () => {\n            // Don't persist if not dirty. Otherwise we would override user's changes.\n            if (dirtyRef.current) {\n                persistState(stateRef.current);\n                dirtyRef.current = false;\n            }\n        };\n        const blur = () => {\n            // Don't persist if not dirty. Otherwise we would override user's changes.\n            if (dirtyRef.current) {\n                persistState(stateRef.current);\n                dirtyRef.current = false;\n            }\n        };\n        window.addEventListener('beforeunload', beforeunload);\n        window.addEventListener('blur', blur);\n        return () => {\n            window.removeEventListener('beforeunload', beforeunload);\n            window.removeEventListener('blur', blur);\n        };\n    }, []);\n\n    const updateState = (updateFunction: StateUpdateFunction) => {\n        let newState = updateFunction(state);\n        stateRef.current = newState;\n        dirtyRef.current = true;\n        setState(newState);\n        debouncedPersistRef.current?.();\n    };\n\n    return (\n        <stateContext.Provider value={{ state, updateState }}>\n            {children}\n        </stateContext.Provider>\n    );\n}\n\nexport function useState() {\n    return React.useContext(stateContext);\n}\n"],"sourceRoot":""}